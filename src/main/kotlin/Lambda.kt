fun main() {
    val a = listOf(1, 2, 3, 4, 5)

    a.forEach { e -> println(e) } // выводим все элементы в листе
    println(a.map { e -> e * 2 }) //умножаем все элементы на 2
    val resultList =
        a.filter { e -> e % 2 == 0 } // будет фильтровать и оставлять только те элементы которые целочисленые
    resultList.forEach { f -> println(f) }
    println(a.reduce { s, e -> s + e }) //будем добавлять элементы
    a.sortedByDescending { it } // сортировка по убыванию it это ключевое слово

    a.any { it > 10 } // ани говорит о том, что будет проверка на тру, есть ли в каком-то поле такое значение
// , которое будет больше 10, если будет 1 значенение тогда тру
    a.all { it < 10 }// возвращает тру, если все условия соотвествуют условию
    a.sum()// суммирует все значения в колекции

    val  numbers = listOf(1,3, -4,2,-11)
    val (positiv,negative) = numbers.partition { it >0  } //partition способен разделить коллекцию на 2, по какому-то признаку, к примеру по
// положительному числу и негативному, тут мы говорим, что если объект больше нуля, то он попадает в одну колекцию
// , а если меньше, то пападает в другую колекцию
    //(positiv,negative) =  так мы способны разделить колекцию на 2

    println(positiv) //потом эти переменные колекций мы можем использовать
    println(negative)

   val result = listOf("a","b","ba", "cds","sd").groupBy { it.length } //мы можем по длине стринга сформировать группы
       // в данном случае мы сгруппировали по длине разные группы, которые будут в хеш мапе
    //в качестве ключа будут длина строки, а в качестве значения сам массив из строк

    println(result)

}


